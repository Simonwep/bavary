{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/ast/tools/optional.js","webpack:///./src/ast/tools/maybe.js","webpack:///./src/ast/tools/expect.js","webpack:///./src/tokenizer/tools/is.js","webpack:///./src/compiler/parser/group.js","webpack:///./src/stream.js","webpack:///./src/ast/tools/check.js","webpack:///./src/compiler/tools/resolve-scope.js","webpack:///./src/compiler/parser/type-value.js","webpack:///./src/compiler/tools/serialize.js","webpack:///./src/compiler/parser/declaration.js","webpack:///./src/compiler/parser/multiplier.js","webpack:///./src/ast/nodes/declaration.js","webpack:///./src/ast/nodes/group.js","webpack:///./src/ast/nodes/multiplier.js","webpack:///./src/ast/nodes/type.js","webpack:///./src/ast/nodes/string.js","webpack:///./src/tokenizer/tools/consume.js","webpack:///./src/index.js","webpack:///./src/compiler/index.js","webpack:///./src/compiler/parser/character-range.js","webpack:///./src/compiler/parser/combinator.js","webpack:///./src/compiler/parser/string.js","webpack:///./src/compiler/parser/type.js","webpack:///./src/compiler/parser/block.js","webpack:///./src/misc/parsing-error.js","webpack:///./src/misc/pretty-print-error.js","webpack:///./node_modules/previous-index-of/index.js","webpack:///./src/ast/index.js","webpack:///./src/ast/tools/combine.js","webpack:///./src/ast/nodes/combinator.js","webpack:///./src/ast/nodes/identifier.js","webpack:///./src/ast/nodes/character-range.js","webpack:///./src/ast/tools/unicode-escape.js","webpack:///./src/ast/nodes/block.js","webpack:///./src/tokenizer/index.js","webpack:///./src/tokenizer/types/str.js","webpack:///./src/tokenizer/tools/escaped.js","webpack:///./src/tokenizer/types/kw.js","webpack:///./src/tokenizer/types/num.js","webpack:///./src/tokenizer/types/punc.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","check","stream","type","vals","next","fn","args","stash","result","recycle","pop","optional","values","expected","hasNext","peek","expectedVal","length","join","expectedPunc","actualPunc","throwError","isPunctuation","isNonWhitespace","isWhiteSpace","isNumeric","serialize","declaration","multiplier","decl","scope","obj","str","pure","decs","dec","ParsingError","source","stashed","index","push","msg","start","end","includes","resolveExports","map","base","variant","subName","has","set","parent","interceptor","Map","group","block","rest","target","nullish","item","tag","characterRange","combinator","string","parse","parseAll","res","expect","maybe","body","combine","parsers","comg","com","sign","types","mp","identifier","ident","predicate","compile","version","resolveScope","typeValue","createStream","ast","definitions","tree","entry","globals","content","from","to","charCode","charCodeAt","delcaration","slice","cpy","splice","matches","Array","isArray","def","newScope","prettyPrintError","Error","super","this","previousIndexOf","MAX_LOOKBACK","trimLine","line","replace","alternative","val","fallback","pred","src","message","prevLineBreak","nextLineBreak","indexOf","sourceLines","lines","prevIndex","nextIndex","substring","trailingLine","resolveSourceLines","col","totalLines","count","ch","countLines","totalLinesMaxStrLength","Math","max","String","trim","omittedLines","lineOffset","padStart","repeat","offset","targetLength","toff","tokenize","defs","declarations","parser","unicodeEscape","parsePoint","sequence","startsWith","hex","char","code","parseInt","consume","tokens","outer","parsed","escaped","v","toLowerCase","number","Number"],"mappings":"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","file":"bavary.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Bavary\"] = factory();\n\telse\n\t\troot[\"Bavary\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","const check = require('./check');\n\n/**\n * Same as check but consumes the value\n * @param stream\n * @param type\n * @param vals\n * @returns {string|*|void|undefined|IteratorResult<any>|Promise<IteratorResult<any>>|null}\n */\nmodule.exports = (stream, type, ...vals) => {\n\n    if (check(stream, type, ...vals)) {\n        return stream.next();\n    }\n\n    return null;\n};\n","/**\n * Restores the previous location if the passed function returns null\n * @param fn\n * @returns {Function}\n */\nmodule.exports = fn => (stream, ...args) => {\n    stream.stash();\n\n    const result = fn(stream, ...args);\n    if (result !== null) {\n        stream.recycle();\n        return result;\n    }\n\n    stream.pop();\n    return null;\n};\n","const optional = require('./optional');\n\n/**\n * Expects a specific token (and optional value).\n * @param stream\n * @param type\n * @param values\n */\nmodule.exports = (stream, type, ...values) => {\n\n    // Check if next token matches type and value\n    const expected = optional(stream, type, ...values);\n    if (expected) {\n        return expected;\n    }\n\n    const next = stream.hasNext() ? stream.peek() : null;\n    if (next !== null) {\n        const expectedVal = values.length ? ` \"${values.join(' / ')}\"` : '';\n        const expectedPunc = next.type === type ? '' : ` (${type})`;\n        const actualPunc = next.type === type ? '' : ` (${next.type})`;\n        stream.throwError(`Expected${expectedVal + expectedPunc} but got \"${next.value}\"${actualPunc}`);\n    } else {\n        stream.throwError('Unxpected end of input.');\n    }\n};\n","module.exports = {\n    isPunctuation: c => c < '0' || c > 'z' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a'),\n    isNonWhitespace: c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_',\n    isWhiteSpace: c => c === '\\t' || c === '\\n' || c === ' ',\n    isNumeric: c => c >= '0' && c <= '9'\n};\n","const serialize = require('../tools/serialize');\nconst declaration = require('./declaration');\nconst multiplier = require('./multiplier');\n\nmodule.exports = multiplier((stream, decl, scope, result = {obj: {}, str: '', pure: true}) => {\n    stream.stash();\n\n    const decs = decl.value;\n    for (let i = 0; i < decs.length; i++) {\n        const dec = decs[i];\n\n        // Parse declaration\n        if (!declaration(stream, dec, scope, result)) {\n            stream.pop();\n\n            // Serialize remaining types\n            serialize(decs, result.obj, true);\n            return null;\n        }\n    }\n\n    stream.recycle();\n    return result.pure ? result.str : result.obj;\n});\n","const ParsingError = require('./misc/parsing-error.js');\n\n/**\n * Creates a new stream out of an array of values and an optional \"source-map\"\n * @param vals\n * @param source Optional source-code to prettify error messages\n * @returns Streaming object\n */\nmodule.exports = (vals, source = null) => {\n    const stashed = [];\n    let index = 0;\n\n    if (typeof source !== 'string' && source !== null) {\n        throw 'Source must be a string.';\n    }\n\n    return {\n        stash: () => stashed.push(index),\n        pop: () => index = stashed.pop(),\n        next: () => vals[index++],\n        peek: () => vals[index],\n        hasNext: () => index < vals.length,\n        recycle: () => stashed.pop(),\n\n        /**\n         * Throws an ParsingError\n         * @param msg\n         */\n        throwError(msg) {\n\n            if (!source) {\n                throw msg;\n            }\n\n            // Throw ParsingError with source-location\n            if (index < vals.length) {\n                const peek = vals[index];\n                throw new ParsingError(source, msg, peek.start, peek.end);\n            } else {\n                throw new ParsingError(source, msg, index, index);\n            }\n        },\n\n        get index() {\n            return index;\n        }\n    };\n};\n","/**\n * Checks if the next token matches type and a list of optional values\n * @param stream\n * @param type\n * @param vals\n * @returns {boolean}\n */\nmodule.exports = (stream, type, ...vals) => {\n    const peek = stream.type ? stream : stream.peek();\n\n    // Check if type matches\n    if (!peek || peek.type !== type) {\n        return false;\n    }\n\n    // Check if value matches\n    return !vals.length || vals.includes(peek.value);\n};\n","/**\n * Builds a new scope and resolves all exports\n * @param decs Declarations\n * @param parent Optional inherited scope\n * @param interceptor Optional interceptor for each declaration\n */\nmodule.exports = (decs, parent, interceptor) => {\n    const map = new Map(parent !== null ? [...parent] : null);\n\n    for (const dec of decs) {\n        const {name, value, type} = dec;\n\n        // Each declaration can only one get once defined\n        if (map.has(name)) {\n            throw `Type \"${name}\" has been already declared.`;\n        } else if (type === 'declaration') {\n\n            // Call interceptor if defined\n            if (typeof interceptor === 'function') {\n                interceptor(dec);\n            }\n\n            // Check if declaration isn't anonym\n            if (name !== null) {\n                map.set(name, value);\n            }\n        } else {\n            throw `Unknown type \"${type}\"`;\n        }\n\n        // If the value is a block it may export types\n        if (value.type === 'block') {\n            resolveExports(value.value, map, name);\n        }\n    }\n\n    return map;\n};\n\nfunction resolveExports(decs, map, base) {\n    for (const {variant, name, value} of decs) {\n        const subName = `${base}:${name}`;\n\n        if (map.has(subName)) {\n            throw `Type \"${subName}\" is already declared in the scope of \"${name}\".`;\n        }\n        if (variant === 'export') {\n            map.set(subName, value);\n        }\n\n        // If it's a block it may also export additional types\n        if (value.type === 'block') {\n            resolveExports(value.value, map, subName);\n        }\n    }\n}\n","const group = require('./group');\nconst block = require('./block');\n\nmodule.exports = (stream, decl, scope, result) => {\n    switch (decl.type) {\n        case 'group': {\n            return group(stream, decl, scope, result);\n        }\n        case 'block': {\n            return block(stream, decl, scope);\n        }\n        default: {\n            throw `Unknown declaration type \"${decl.type}\"`;\n        }\n    }\n};\n","/**\n * Serializes, e.g nullish, tagged types which got not matched\n * @param rest Array of declaration\n * @param target Result-obj\n * @param nullish Override existing values\n */\nmodule.exports = function serialize(rest, target, nullish = false) {\n    for (const item of rest) {\n\n        // Check if item is a type, has a tag and the tag wasn't already used\n        if (item.type === 'type' && item.tag && ((typeof target[item.tag] === 'undefined') || nullish)) {\n            target[item.tag] = null;\n        } else if (item.type === 'group') {\n            serialize(item.value, target);\n        }\n    }\n};\n","const characterRange = require('./character-range');\r\nconst combinator = require('./combinator');\r\nconst string = require('./string');\r\nconst type = require('./type');\r\n\r\nmodule.exports = (stream, decl, scope, result = {obj: {}, str: '', pure: true}) => {\r\n    stream.stash();\r\n\r\n    switch (decl.type) {\r\n        case 'combinator': {\r\n\r\n            if (!combinator(stream, decl, scope, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'string': {\r\n\r\n            if (!string(stream, decl, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'character-range': {\r\n\r\n            if (!characterRange(stream, decl, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'type': {\r\n\r\n            if (!type(stream, decl, scope, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'group': {\r\n            const res = require('./group')(stream, decl, scope, result);\r\n\r\n            if (!res) {\r\n                if (decl.multiplier) {\r\n                    const {type} = decl.multiplier;\r\n\r\n                    // Check if group need to be matched\r\n                    if (type !== 'one-infinity') {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    stream.recycle();\r\n    return true;\r\n};\r\n","module.exports = fn => (stream, decl, scope, ...rest) => {\n    const parse = () => fn(stream, decl, scope, ...rest);\n    const parseAll = () => {\n        const values = [];\n\n        for (let res; (res = parse());) {\n            values.push(res);\n        }\n\n        return values;\n    };\n\n    // Check if there's a multiplier\n    if (decl.multiplier) {\n        const {type, value} = decl.multiplier;\n\n        switch (type) {\n            case 'zero-infinity': {\n                return parseAll();\n            }\n            case 'one-infinity': {\n                const values = parseAll();\n\n                if (!values.length) {\n                    return null;\n                }\n\n                return values;\n            }\n            case 'range': {\n                const {start, end} = value;\n                const values = parseAll();\n\n                if (values.length < start || values.length > end) {\n                    return null;\n                }\n\n                return values;\n            }\n        }\n    }\n\n    return parse();\n};\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst group = require('./group');\nconst type = require('./type');\n\nmodule.exports = maybe(stream => {\n\n    // Parse optional variant\n    const variant = optional(stream, 'kw', 'entry', 'default', 'export');\n\n    // Parse\n    const target = type(stream);\n\n    if (target) {\n        expect(stream, 'punc', '=');\n\n        // Declaration cannot have multipliers\n        if (target.multiplier) {\n            return stream.throwError('Declaration type cannot contain multipliers.');\n        }\n\n        // Neither can they have tag\n        if (target.tag) {\n            return stream.throwError('Declaration type cannot have a tag.');\n        }\n\n    } else if (!variant) {\n        return stream.throwError('Expected declaration.');\n    }\n\n\n    // A declaration value could be either a group or scoped block\n    const body = group(stream) || require('./block')(stream);\n    if (!body) {\n        return stream.throwError('A declaration consists of one group.');\n    }\n\n    // If the variant is 'export' a block is required\n    if (variant === 'export' && body.type !== 'block') {\n        return stream.throwError('Types can only be exported in blocks.');\n    }\n\n    return {\n        type: 'declaration',\n        name: target ? target.value : null,\n        variant: variant ? variant.value : null,\n        value: body\n    };\n});\n","const optional = require('../tools/optional');\nconst combine = require('../tools/combine');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst check = require('../tools/check');\nconst multiplier = require('./multiplier');\nconst combinator = require('./combinator');\n\nmodule.exports = maybe(stream => {\n\n    // It may be a group\n    if (!optional(stream, 'punc', '[')) {\n        return null;\n    }\n\n    const values = [];\n    const parsers = combine(\n        require('./type'),\n        require('./group'),\n        require('./character-range'),\n        require('./string')\n    );\n\n    let comg;\n    while (!check(stream, 'punc', ']')) {\n        const value = parsers(stream);\n        const com = combinator(stream);\n\n        if (!value) {\n            return stream.throwError('Expected a type, group or raw string.');\n        }\n\n        if (com) {\n\n            // Append to previous group\n            if (comg) {\n                if (com.value === comg.sign) {\n                    comg.value.push(value);\n                    continue;\n                } else {\n                    values.push(comg);\n                    comg = null;\n                }\n            }\n\n            // Consume next\n            comg = {\n                type: 'combinator',\n                sign: com.value,\n                value: [value]\n            };\n        } else if (comg) {\n            comg.value.push(value);\n            values.push(comg);\n            comg = null;\n        } else {\n            values.push(value);\n        }\n    }\n\n    if (comg) {\n        values.push(comg);\n    }\n\n    expect(stream, 'punc', ']');\n    return {\n        type: 'group',\n        multiplier: multiplier(stream),\n        value: values\n    };\n});\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\n\nconst types = {\n    '*': 'zero-infinity',\n    '+': 'one-infinity',\n    '?': 'optional'\n};\n\nmodule.exports = maybe(stream => {\n    const mp = optional(stream, 'punc', '*', '+', '?', '{');\n\n    if (mp && mp.value === '{') {\n        const start = expect(stream, 'num');\n        expect(stream, 'punc', ',');\n\n        const end = expect(stream, 'num');\n        if (start.value < 0 || end.value < 0) {\n            return stream.throwError('Range values cannot contain negative values.');\n        } else if (end.value - start.value < 0) {\n            return stream.throwError('The difference between start and end-value cannot be negative or zero.');\n        }\n\n        expect(stream, 'punc', '}');\n        return {\n            type: 'range',\n            value: {\n                start: start.value,\n                end: end.value\n            }\n        };\n    }\n\n    return mp ? {\n        type: types[mp.value],\n        value: mp.value\n    } : null;\n});\n","const identifier = require('./identifier');\nconst optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst multiplier = require('./multiplier');\nconst string = require('./string');\n\nmodule.exports = maybe(stream => {\n\n    // It MAY be a type, dosn't need to though.\n    if (!optional(stream, 'punc', '<')) {\n        return null;\n    }\n\n    const ident = identifier(stream);\n    if (!ident) {\n        return stream.throwError('Expected identifier.');\n    }\n\n    let tag = null;\n    if (optional(stream, 'punc', '#')) {\n        tag = string(stream) || identifier(stream);\n\n        if (!tag) {\n            return stream.throwError('Expected string or identifier as tag.');\n        }\n\n        tag = tag.value;\n    }\n\n    expect(stream, 'punc', '>');\n    return {\n        type: 'type',\n        multiplier: multiplier(stream),\n        value: ident.value,\n        tag\n    };\n});\n","const optional = require('../tools/optional');\nconst maybe = require('../tools/maybe');\n\nmodule.exports = maybe(stream => {\n    const string = optional(stream, 'str');\n\n    if (string && !string.value.length) {\n        return stream.throwError('Strings shouldn\\'t be empty.');\n    }\n\n    return string ? {\n        type: 'string',\n        value: string.value\n    } : null;\n});\n","module.exports = (stream, predicate) => {\n    let result = '';\n\n    while (stream.hasNext() && predicate(stream.peek())) {\n        result += stream.next();\n    }\n\n    return result;\n};\n","module.exports = {\n    compile: require('./compiler'),\n    version: '0.0.2'\n};\n","const resolveScope = require('./tools/resolve-scope');\nconst typeValue = require('./parser/type-value');\nconst createStream = require('../stream');\nconst ast = require('../ast');\n\nmodule.exports = definitions => {\n    const tree = ast(definitions);\n    let entry = null;\n\n    // Resolve entities in the global scope\n    const globals = resolveScope(tree, null, ({variant, name, value}) => {\n        if (variant === 'entry') {\n\n            // There can only be one entry type\n            if (entry) {\n                throw `There can only be one entry type. Got \"${name}\" as second one.`;\n            }\n\n            entry = value;\n        }\n    });\n\n    // Check if entry node is declared\n    if (!entry) {\n        throw 'Couldn\\'t resolve entry type. Use the entry keyword to declare one.';\n    }\n\n    return content => {\n        const stream = createStream(content);\n        const res = typeValue(stream, entry, globals);\n        return stream.hasNext() ? null : res;\n    };\n};\n","/**\n * Parses a character-range\n * @param stream Character-stream\n * @param value\n * @param result\n * @returns {null|*}\n */\nmodule.exports = (stream, {value: {from, to}}, result) => {\n    if (!stream.hasNext()) {\n        return false;\n    }\n\n    // Resolve next character / char-code\n    const value = stream.next();\n    const charCode = value.charCodeAt(0);\n\n    // Check if charcode matches given range\n    if (charCode >= from && charCode <= to) {\n        result.str += value;\n        return true;\n    }\n\n    return false;\n};\n","const serialize = require('../tools/serialize');\n\nmodule.exports = (stream, decl, scope, result) => {\n    const delcaration = require('./declaration');\n    stream.stash();\n\n    switch (decl.sign) {\n        case '|': {\n\n            // Match one of the items\n            const decs = decl.value;\n            for (let i = 0; i < decs.length; i++) {\n                if (delcaration(stream, decs[i], scope, result)) {\n                    stream.recycle();\n\n                    // Serialize remaining types\n                    serialize(decs.slice(i), result.obj);\n                    return true;\n                }\n            }\n\n            break;\n        }\n        case '&&':\n        case '&': {\n            const cpy = [...decl.value];\n\n            // Match items ignoring the order\n            for (let i = 0; i < cpy.length; i++) {\n                if (delcaration(stream, cpy[i], scope, result)) {\n                    cpy.splice(i, 1);\n                    i = -1;\n                }\n            }\n\n            // Serialize remaining types\n            serialize(cpy, result.obj);\n\n            if (!cpy.length || (decl.sign === '&&' && cpy.length < decl.value.length)) {\n                stream.recycle();\n                return true;\n            }\n\n            break;\n        }\n        default: {\n            throw `Unknown combinator \"${decl.sign}\"`;\n        }\n    }\n\n    stream.pop();\n    return null;\n};\n","/**\n * Parses a single string\n * @param stream Character-stream\n * @param value Deconstructed value of a string-type\n * @param result\n * @returns {null|*}\n */\nmodule.exports = (stream, {value}, result) => {\n    if (!stream.hasNext()) {\n        return false;\n    }\n\n    stream.stash();\n    for (let i = 0; i < value.length; i++) {\n        const next = stream.next();\n\n        // Check for type mismatch\n        if (next !== value[i]) {\n            stream.pop();\n            return false;\n        }\n    }\n\n    stream.recycle();\n    result.str += value;\n    return true;\n};\n","const multiplier = require('./multiplier');\n\nmodule.exports = (stream, decl, scope, result) => {\n    const typeValue = require('./type-value');\n    const {value} = decl;\n\n    // Lookup parser\n    if (!scope.has(value)) {\n        throw `Cannot resolve \"${value}\"`;\n    }\n\n    // Parse\n    stream.stash();\n    const body = scope.get(value);\n\n    // Type may have a multiplier attached to it\n    const matches = multiplier(\n        () => typeValue(stream, body, scope)\n    )(stream, decl, scope, result);\n\n    // Tags can be nullish\n    if (decl.tag) {\n        result.obj[decl.tag] = matches; // Save tag-result (can be null)\n\n        if (matches) {\n\n            // Since something was matched the result is not anymore \"just a string\"\n            result.pure = false;\n        }\n    }\n\n    if (!matches) {\n\n        // Restore previous stack position\n        stream.pop();\n\n        // Declaration may be still optional through a '?'\n        return decl.multiplier && decl.multiplier.type === 'optional';\n    }\n\n    if (!decl.tag) {\n        if (Array.isArray(matches)) {\n            result.str += matches.join(''); // Concat string sequences\n        } else if (typeof matches === 'string') {\n            result.str += matches;\n        } else {\n            throw `Type \"${decl.value}\" is missing a tag.`;\n        }\n    }\n\n    stream.recycle();\n    return true;\n};\n","const resolveScope = require('../tools/resolve-scope');\nconst group = require('./group');\n\nmodule.exports = (stream, decl, scope) => {\n\n    // Inherit current scope\n    let def = null;\n    const newScope = resolveScope(decl.value, scope, ({variant, value}) => {\n        if (variant === 'default') {\n            if (def !== null) {\n                throw 'There can only be one default export.';\n            }\n\n            def = value;\n        } else if (variant === 'entry') {\n            throw 'The entry type needs to be in the global scope.';\n        }\n    });\n\n    if (!def) {\n        throw 'Missing default export.';\n    }\n\n    return group(stream, def, newScope);\n};\n","const prettyPrintError = require('./pretty-print-error');\n\nmodule.exports = class ParsingError extends Error {\n\n    /**\n     * Sytax-error with message and position\n     * @param source\n     * @param msg\n     * @param start\n     * @param end\n     */\n    constructor(source, msg, start, end) {\n        super(`\\n${prettyPrintError(source, msg, start, end)}`);\n        this.start = start;\n        this.end = end;\n        this.name = 'Parsing Error';\n    }\n};\n","const previousIndexOf = require('previous-index-of');\nconst MAX_LOOKBACK = 10;\n\n/* eslint-disable no-console */\n/**\n * Pretty-prints an error-message\n * @param src the source-code\n * @param message error message\n * @param start error-offset\n * @param end error-end index\n */\nmodule.exports = (src, message, start, end) => {\n    const prevLineBreak = alternative(previousIndexOf(src, '\\n', start), 0);\n    const nextLineBreak = alternative(src.indexOf('\\n', end), src.length);\n    const sourceLines = resolveSourceLines(src, nextLineBreak);\n    const col = (start - prevLineBreak);\n    let msg = '';\n\n    const totalLines = countLines(src);\n    const totalLinesMaxStrLength = Math.max(String(totalLines).length, 2);\n\n    // Remove empty trailing lines\n    while (sourceLines.length && !sourceLines[0].trim()) {\n        sourceLines.splice(0, 1);\n    }\n\n    // Check if lines where omitted\n    const omittedLines = totalLines - sourceLines.length;\n    if (omittedLines >= 1) {\n        msg += `... (${omittedLines} line${omittedLines === 1 ? '' : 's'} omitted)\\n`;\n    }\n\n    // Pretty-print lines\n    for (let i = 0; i < sourceLines.length; i++) {\n        const line = sourceLines[i];\n        const lineOffset = totalLines - sourceLines.length + i + 1;\n        const lineCount = String(lineOffset).padStart(totalLinesMaxStrLength, '0');\n        msg += `${lineCount}: ${line}\\n`;\n    }\n\n    msg += `${' '.repeat(col + totalLinesMaxStrLength)}^\\n`;\n    msg += message;\n    return msg;\n};\n\nfunction trimLine(line) {\n    return line.replace(/^[\\n\\r]+|[\\n\\r ]+$/g, '');\n}\n\nfunction countLines(src) {\n    let count = 0;\n\n    for (const ch of src) {\n        count += ch === '\\n' ? 1 : 0;\n    }\n\n    return count;\n}\n\nfunction resolveSourceLines(src, end) {\n    const lines = [];\n\n    // Backtrack lines\n    let prevIndex = end;\n    while (lines.length < MAX_LOOKBACK) {\n        const nextIndex = previousIndexOf(src, '\\n', prevIndex - 1);\n\n        if (~nextIndex) {\n            const line = src.substring(nextIndex, prevIndex);\n            lines.splice(0, 0, trimLine(line));\n            prevIndex = nextIndex;\n        } else {\n            break;\n        }\n    }\n\n    if (!lines.length && src.length) {\n        lines.push(trimLine(src));\n    } else if (lines.length < MAX_LOOKBACK) {\n        const trailingLine = trimLine(src.slice(0, prevIndex));\n\n        // The first line won't be matched by the previous loop.\n        if (trailingLine) {\n            lines.splice(0, 0, trailingLine);\n        }\n    }\n\n    return lines;\n}\n\nfunction alternative(val, fallback, pred = -1) {\n    return val === pred ? fallback : val;\n}\n","/**\n * Returns the previous index of a string at a given offset.\n * If the target is not a string or the offset is below the length of the target\n * it returns -1.\n *\n * If offset isn't a string it will be set to the length of the source string.\n *\n * @param str Source string\n * @param target Target string\n * @param offset Offset (inclusive)\n * @returns {number|*} The offset of the target string or -1 if the offset wasn't found.\n */\nmodule.exports = (str, target, offset) => {\n\n    // Immediatly return -1 if offset is below target length or non-strings where used as target or source\n    if (typeof target !== 'string' || typeof str !== 'string' || offset < target.length - 1) {\n        return -1;\n    }\n\n    // Set offset to the length of the source string if it isn't a number\n    if (typeof offset !== 'number') {\n        offset = str.length - 1;\n    }\n\n    // Reverse-search for target-string offset\n    const targetLength = target.length - 1;\n    for (let i = offset, toff = targetLength; i >= 0; i--) {\n\n        if (str[i] === target[toff]) {\n            toff--;\n\n            // Check if target string got fully matched\n            if (!~toff) {\n                return i;\n            }\n        } else if (toff !== targetLength) {\n            toff = targetLength;\n            i++;\n        }\n    }\n\n    return -1;\n};\n","const declaration = require('./nodes/declaration');\nconst tokenize = require('../tokenizer');\nconst createStream = require('../stream');\n\n/**\n * Converts a array of tokens into a ast-tree\n * @param defs\n */\nmodule.exports = defs => {\n    const stream = createStream(tokenize(defs), defs);\n    const declarations = [];\n\n    while (stream.hasNext()) {\n        const dec = declaration(stream);\n\n        if (dec) {\n            declarations.push(dec);\n        } else {\n            return stream.throwError('Expected type-declaration.');\n        }\n    }\n\n    return declarations;\n};\n","/**\n * Accepts a list of parser and returns the first who matches the input\n * @param parsers\n * @returns {Function}\n */\nmodule.exports = (...parsers) => stream => {\n    for (const parser of parsers) {\n        const result = parser(stream);\n\n        if (result) {\n            return result;\n        }\n    }\n\n    return null;\n};\n","const optional = require('../tools/optional');\nconst maybe = require('../tools/maybe');\n\nmodule.exports = maybe(stream => {\n    const combinator = optional(stream, 'punc', '|', '&');\n\n    if (!combinator) {\n        return null;\n    }\n\n    // It may be a extended combinator\n    if (combinator.value === '&' && optional(stream, 'punc', '&')) {\n        combinator.value += '&';\n    }\n\n    return {\n        type: 'combinator',\n        value: combinator.value\n    };\n});\n","const maybe = require('../tools/maybe');\n\n/**\n * Parses an identifier made out of keywords, numbers or hyphens\n * @type {Function}\n */\nmodule.exports = maybe(stream => {\n    let name = '';\n\n    while (stream.hasNext(true)) {\n        const {type, value} = stream.peek(true);\n\n        if (type === 'kw' || type === 'num' || (type === 'punc' && (value === '-' || value === ':'))) {\n            name += value;\n            stream.next(true);\n        } else {\n            break;\n        }\n    }\n\n    if (!name.length) {\n        return stream.throwError('An identifier cannot be empty.');\n    }\n\n    return {\n        type: 'identifier',\n        value: name || null\n    };\n});\n","const unicodeEscape = require('../tools/unicode-escape');\r\nconst optional = require('../tools/optional');\r\nconst maybe = require('../tools/maybe');\r\n\r\nconst parsePoint = stream => {\r\n    const str = optional(stream, 'str');\r\n\r\n    if (str) {\r\n        const {value} = str;\r\n        return value.length === 1 ? value.charCodeAt(0) : null;\r\n    }\r\n\r\n    return unicodeEscape(stream);\r\n};\r\n\r\nmodule.exports = maybe(stream => {\r\n    let from = parsePoint(stream);\r\n\r\n    // The keyword 'to' indicates a character range\r\n    if (from === null || !optional(stream, 'kw', 'to')) {\r\n        return null;\r\n    }\r\n\r\n    let to = parsePoint(stream);\r\n    if (to === null) {\r\n        return stream.throwError('Expected range-end');\r\n    }\r\n\r\n    if (to < from) {\r\n        [to, from] = [from, to];\r\n    }\r\n\r\n    return {\r\n        type: 'character-range',\r\n        value: {\r\n            from,\r\n            to\r\n        }\r\n    };\r\n});\r\n","const optional = require('./optional');\nconst maybe = require('./maybe');\n\nmodule.exports = maybe(stream => {\n\n    if (!optional(stream, 'punc', '\\\\') || !stream.hasNext()) {\n        return null;\n    }\n\n    const sequence = String(stream.next().value);\n    if (!sequence.startsWith('u')) {\n        return null;\n    }\n\n    // Validate length of sequence\n    if (sequence.length !== 5) {\n        return stream.throwError('An unicode-escape sequence consists out of an \"u\" followed by a code-point.');\n    }\n\n    // Validate char-codes\n    const hex = sequence.slice(1);\n    for (const char of hex) {\n        const code = char.charCodeAt(0);\n\n        if (code < 48 || (code > 57 && code < 97) || code > 102) {\n            return stream.throwError('Invalid unicode-range.');\n        }\n    }\n\n    return parseInt(hex, 16);\n});\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst check = require('../tools/check');\nconst declaration = require('./declaration');\n\nmodule.exports = maybe(stream => {\n\n    // It may be a block\n    if (!optional(stream, 'punc', '{')) {\n        return null;\n    }\n\n    // Parse declarations\n    const declarations = [];\n\n    while (!check(stream, 'punc', '}')) {\n        declarations.push(declaration(stream));\n    }\n\n    expect(stream, 'punc', '}');\n    return {\n        type: 'block',\n        value: declarations\n    };\n});\n","const createStream = require('../stream');\nconst consume = require('./tools/consume');\nconst {isWhiteSpace} = require('./tools/is');\n\nconst parser = [\n    require('./types/str'),\n    require('./types/kw'),\n    require('./types/num'),\n    require('./types/punc')\n];\n\n/**\n * Parses a sequence of characters into a list of processable tokens\n * @param str\n * @returns {[]}\n */\nmodule.exports = str => {\n    const stream = createStream(str);\n    const tokens = [];\n\n    /* eslint-disable no-labels */\n    outer: while (stream.hasNext()) {\n\n        // Ignore whitespace\n        consume(stream, isWhiteSpace);\n\n        if (!stream.hasNext()) {\n            break;\n        }\n\n        // Find matching parser\n        for (const parse of parser) {\n            const start = stream.index;\n            const parsed = parse(stream);\n\n            if (!parsed) {\n                continue;\n            }\n\n            // Check if token could be the beginning of a comment\n            if (parsed.value === '/' && stream.hasNext() && stream.peek() === '/') {\n                while (stream.hasNext()) {\n                    if (stream.peek() === '\\n') {\n                        break;\n                    }\n\n                    stream.next();\n                }\n\n                continue outer;\n            }\n\n            tokens.push({\n                ...parsed, start,\n                end: stream.index\n            });\n\n            continue outer;\n        }\n\n        throw 'Failed to parse input sequence.';\n    }\n\n    return tokens;\n};\n","const escaped = require('../tools/escaped');\n\nmodule.exports = stream => {\n    for (const char of ['\\'', '\"', '`']) {\n        stream.stash();\n\n        if (stream.peek() === char) {\n            stream.next();\n\n            const value = escaped(stream, char);\n            if (value !== null) {\n                return {\n                    type: 'str',\n                    value\n                };\n            }\n        }\n\n        stream.pop();\n    }\n\n    return null;\n};\n","module.exports = (stream, end) => {\n    let escaped = false;\n    let str = '';\n\n    for (let ch = stream.next(); ; ch = stream.next()) {\n        if (escaped) {\n            str += ch;\n            escaped = false;\n        } else if (ch === '\\\\') {\n            escaped = true;\n        } else if (ch === end) {\n            return str;\n        } else if (!stream.hasNext()) {\n            break;\n        } else {\n            str += ch;\n        }\n    }\n\n    return null;\n};\n","const {isNonWhitespace, isNumeric} = require('../tools/is');\nconst consume = require('../tools/consume');\n\nmodule.exports = stream => {\n\n    if (isNonWhitespace(stream.peek())) {\n        const str = consume(stream, v => isNonWhitespace(v) || isNumeric(v));\n\n        return str ? {\n            type: 'kw',\n            value: str.toLowerCase()\n        } : null;\n    }\n\n    return null;\n\n};\n","const {isNumeric} = require('../tools/is');\n\nmodule.exports = stream => {\n\n    let number = '';\n    while (stream.hasNext()) {\n        const ch = stream.peek();\n\n        if (isNumeric(ch)) {\n            number += ch;\n        } else {\n            break;\n        }\n\n        stream.next();\n    }\n\n    return number.length ? {\n        type: 'num',\n        value: Number(number)\n    } : null;\n};\n","const {isPunctuation} = require('../tools/is');\r\n\r\nmodule.exports = stream => {\r\n\r\n    if (isPunctuation(stream.peek())) {\r\n        return {\r\n            type: 'punc',\r\n            value: stream.next()\r\n        };\r\n    }\r\n\r\n    return null;\r\n};\r\n"],"sourceRoot":""}