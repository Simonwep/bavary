{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/ast/tools/optional.js","webpack:///./src/ast/tools/maybe.js","webpack:///./src/ast/tools/expect.js","webpack:///./src/tokenizer/tools/is.js","webpack:///./src/compiler/parser/group.js","webpack:///./src/stream.js","webpack:///./src/ast/tools/check.js","webpack:///./src/compiler/tools/resolve-scope.js","webpack:///./src/compiler/parser/type-value.js","webpack:///./src/compiler/parser/declaration.js","webpack:///./src/compiler/parser/multiplier.js","webpack:///./src/ast/nodes/declaration.js","webpack:///./src/ast/nodes/group.js","webpack:///./src/ast/nodes/multiplier.js","webpack:///./src/ast/nodes/type.js","webpack:///./src/ast/nodes/string.js","webpack:///./src/tokenizer/tools/consume.js","webpack:///./src/index.js","webpack:///./src/compiler/index.js","webpack:///./src/compiler/parser/character-range.js","webpack:///./src/compiler/parser/combinator.js","webpack:///./src/compiler/parser/string.js","webpack:///./src/compiler/parser/type.js","webpack:///./src/compiler/parser/block.js","webpack:///./src/misc/parsing-error.js","webpack:///./src/misc/pretty-print-error.js","webpack:///./node_modules/previous-index-of/index.js","webpack:///./src/ast/index.js","webpack:///./src/ast/tools/combine.js","webpack:///./src/ast/nodes/combinator.js","webpack:///./src/ast/nodes/identifier.js","webpack:///./src/ast/nodes/character-range.js","webpack:///./src/ast/tools/unicode-escape.js","webpack:///./src/ast/nodes/block.js","webpack:///./src/tokenizer/index.js","webpack:///./src/tokenizer/types/str.js","webpack:///./src/tokenizer/tools/escaped.js","webpack:///./src/tokenizer/types/kw.js","webpack:///./src/tokenizer/types/num.js","webpack:///./src/tokenizer/types/punc.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","check","stream","type","vals","next","fn","args","stash","result","recycle","pop","optional","values","expected","hasNext","peek","expectedVal","length","join","expectedPunc","actualPunc","throwError","isPunctuation","isNonWhitespace","isWhiteSpace","isNumeric","declaration","multiplier","decl","scope","obj","str","pure","dec","ParsingError","source","stashed","index","push","msg","start","end","includes","resolveExports","decs","map","base","variant","subName","has","set","parent","interceptor","Map","group","block","characterRange","combinator","string","rest","parse","parseAll","res","expect","maybe","target","tag","body","combine","parsers","comg","com","sign","types","mp","identifier","ident","predicate","compile","version","resolveScope","typeValue","createStream","ast","definitions","tree","entry","globals","content","from","to","charCode","charCodeAt","delcaration","val","cpy","splice","matches","Array","isArray","def","newScope","prettyPrintError","Error","super","this","previousIndexOf","MAX_LOOKBACK","trimLine","line","replace","alternative","fallback","pred","src","message","prevLineBreak","nextLineBreak","indexOf","sourceLines","lines","prevIndex","nextIndex","substring","trailingLine","slice","resolveSourceLines","col","totalLines","count","ch","countLines","totalLinesMaxStrLength","Math","max","String","trim","omittedLines","lineOffset","padStart","repeat","offset","targetLength","toff","tokenize","defs","declarations","parser","unicodeEscape","parsePoint","sequence","startsWith","hex","char","code","parseInt","consume","tokens","outer","parsed","escaped","v","toLowerCase","number","Number"],"mappings":"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","file":"bavary.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Bavary\"] = factory();\n\telse\n\t\troot[\"Bavary\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n","const check = require('./check');\n\n/**\n * Same as check but consumes the value\n * @param stream\n * @param type\n * @param vals\n * @returns {string|*|void|undefined|IteratorResult<any>|Promise<IteratorResult<any>>|null}\n */\nmodule.exports = (stream, type, ...vals) => {\n\n    if (check(stream, type, ...vals)) {\n        return stream.next();\n    }\n\n    return null;\n};\n","/**\n * Restores the previous location if the passed function returns null\n * @param fn\n * @returns {Function}\n */\nmodule.exports = fn => (stream, ...args) => {\n    stream.stash();\n\n    const result = fn(stream, ...args);\n    if (result !== null) {\n        stream.recycle();\n        return result;\n    }\n\n    stream.pop();\n    return null;\n};\n","const optional = require('./optional');\n\n/**\n * Expects a specific token (and optional value).\n * @param stream\n * @param type\n * @param values\n */\nmodule.exports = (stream, type, ...values) => {\n\n    // Check if next token matches type and value\n    const expected = optional(stream, type, ...values);\n    if (expected) {\n        return expected;\n    }\n\n    const next = stream.hasNext() ? stream.peek() : null;\n    if (next !== null) {\n        const expectedVal = values.length ? ` \"${values.join(' / ')}\"` : '';\n        const expectedPunc = next.type === type ? '' : ` (${type})`;\n        const actualPunc = next.type === type ? '' : ` (${next.type})`;\n        stream.throwError(`Expected${expectedVal + expectedPunc} but got \"${next.value}\"${actualPunc}`);\n    } else {\n        stream.throwError('Unxpected end of input.');\n    }\n};\n","module.exports = {\n    isPunctuation: c => c < '0' || c > 'z' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a'),\n    isNonWhitespace: c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_',\n    isWhiteSpace: c => c === '\\t' || c === '\\n' || c === ' ',\n    isNumeric: c => c >= '0' && c <= '9'\n};\n","const declaration = require('./declaration');\r\nconst multiplier = require('./multiplier');\r\n\r\nmodule.exports = multiplier((stream, decl, scope, result = {obj: {}, str: '', pure: true}) => {\r\n    stream.stash();\r\n\r\n    for (const dec of decl.value) {\r\n\r\n        // Parse declaration\r\n        if (!declaration(stream, dec, scope, result)) {\r\n            stream.pop();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    stream.recycle();\r\n    return result.pure ? result.str : result.obj;\r\n});\r\n","const ParsingError = require('./misc/parsing-error.js');\n\n/**\n * Creates a new stream out of an array of values and an optional \"source-map\"\n * @param vals\n * @param source Optional source-code to prettify error messages\n * @returns Streaming object\n */\nmodule.exports = (vals, source = null) => {\n    const stashed = [];\n    let index = 0;\n\n    if (typeof source !== 'string' && source !== null) {\n        throw 'Source must be a string.';\n    }\n\n    return {\n        stash: () => stashed.push(index),\n        pop: () => index = stashed.pop(),\n        next: () => vals[index++],\n        peek: () => vals[index],\n        hasNext: () => index < vals.length,\n        recycle: () => stashed.pop(),\n\n        /**\n         * Throws an ParsingError\n         * @param msg\n         */\n        throwError(msg) {\n\n            if (!source) {\n                throw msg;\n            }\n\n            // Throw ParsingError with source-location\n            if (index < vals.length) {\n                const peek = vals[index];\n                throw new ParsingError(source, msg, peek.start, peek.end);\n            } else {\n                throw new ParsingError(source, msg, index, index);\n            }\n        },\n\n        get index() {\n            return index;\n        }\n    };\n};\n","/**\n * Checks if the next token matches type and a list of optional values\n * @param stream\n * @param type\n * @param vals\n * @returns {boolean}\n */\nmodule.exports = (stream, type, ...vals) => {\n    const peek = stream.type ? stream : stream.peek();\n\n    // Check if type matches\n    if (!peek || peek.type !== type) {\n        return false;\n    }\n\n    // Check if value matches\n    return !vals.length || vals.includes(peek.value);\n};\n","/**\n * Builds a new scope and resolves all exports\n * @param decs Declarations\n * @param parent Optional inherited scope\n * @param interceptor Optional interceptor for each declaration\n */\nmodule.exports = (decs, parent, interceptor) => {\n    const map = new Map(parent !== null ? [...parent] : null);\n\n    for (const dec of decs) {\n        const {name, value, type} = dec;\n\n        // Each declaration can only one get once defined\n        if (map.has(name)) {\n            throw `Type \"${name}\" has been already declared.`;\n        } else if (type === 'declaration') {\n\n            // Call interceptor if defined\n            if (typeof interceptor === 'function') {\n                interceptor(dec);\n            }\n\n            // Check if declaration isn't anonym\n            if (name !== null) {\n                map.set(name, value);\n            }\n        } else {\n            throw `Unknown type \"${type}\"`;\n        }\n\n        // If the value is a block it may export types\n        if (value.type === 'block') {\n            resolveExports(value.value, map, name);\n        }\n    }\n\n    return map;\n};\n\nfunction resolveExports(decs, map, base) {\n    for (const {variant, name, value} of decs) {\n        const subName = `${base}:${name}`;\n\n        if (map.has(subName)) {\n            throw `Type \"${subName}\" is already declared in the scope of \"${name}\".`;\n        }\n        if (variant === 'export') {\n            map.set(subName, value);\n        }\n\n        // If it's a block it may also export additional types\n        if (value.type === 'block') {\n            resolveExports(value.value, map, subName);\n        }\n    }\n}\n","const group = require('./group');\nconst block = require('./block');\n\nmodule.exports = (stream, decl, scope, result) => {\n    switch (decl.type) {\n        case 'group': {\n            return group(stream, decl, scope, result);\n        }\n        case 'block': {\n            return block(stream, decl, scope);\n        }\n        default: {\n            throw `Unknown declaration type \"${decl.type}\"`;\n        }\n    }\n};\n","const characterRange = require('./character-range');\r\nconst combinator = require('./combinator');\r\nconst string = require('./string');\r\nconst type = require('./type');\r\n\r\nmodule.exports = (stream, decl, scope, result = {obj: {}, str: '', pure: true}) => {\r\n    stream.stash();\r\n\r\n    switch (decl.type) {\r\n        case 'combinator': {\r\n\r\n            if (!combinator(stream, decl, scope, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'string': {\r\n\r\n            if (!string(stream, decl, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'character-range': {\r\n\r\n            if (!characterRange(stream, decl, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'type': {\r\n\r\n            if (!type(stream, decl, scope, result)) {\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 'group': {\r\n            const res = require('./group')(stream, decl, scope, result);\r\n\r\n            if (!res) {\r\n                if (decl.multiplier) {\r\n                    const {type} = decl.multiplier;\r\n\r\n                    // Check if group need to be matched\r\n                    if (type !== 'one-infinity') {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                stream.pop();\r\n                return false;\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    stream.recycle();\r\n    return true;\r\n};\r\n","module.exports = fn => (stream, decl, scope, ...rest) => {\n    const parse = () => fn(stream, decl, scope, ...rest);\n    const parseAll = () => {\n        const values = [];\n\n        for (let res; (res = parse());) {\n            values.push(res);\n        }\n\n        return values;\n    };\n\n    // Check if there's a multiplier\n    if (decl.multiplier) {\n        const {type, value} = decl.multiplier;\n\n        switch (type) {\n            case 'zero-infinity': {\n                return parseAll();\n            }\n            case 'one-infinity': {\n                const values = parseAll();\n\n                if (!values.length) {\n                    return null;\n                }\n\n                return values;\n            }\n            case 'range': {\n                const {start, end} = value;\n                const values = parseAll();\n\n                if (values.length < start || values.length > end) {\n                    return null;\n                }\n\n                return values;\n            }\n        }\n    }\n\n    return parse();\n};\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst group = require('./group');\nconst type = require('./type');\n\nmodule.exports = maybe(stream => {\n\n    // Parse optional variant\n    const variant = optional(stream, 'kw', 'entry', 'default', 'export');\n\n    // Parse\n    const target = type(stream);\n\n    if (target) {\n        expect(stream, 'punc', '=');\n\n        // Declaration cannot have multipliers\n        if (target.multiplier) {\n            return stream.throwError('Declaration type cannot contain multipliers.');\n        }\n\n        // Neither can they have tag\n        if (target.tag) {\n            return stream.throwError('Declaration type cannot have a tag.');\n        }\n\n    } else if (!variant) {\n        return stream.throwError('Expected declaration.');\n    }\n\n\n    // A declaration value could be either a group or scoped block\n    const body = group(stream) || require('./block')(stream);\n    if (!body) {\n        return stream.throwError('A declaration consists of one group.');\n    }\n\n    // If the variant is 'export' a block is required\n    if (variant === 'export' && body.type !== 'block') {\n        return stream.throwError('Types can only be exported in blocks.');\n    }\n\n    return {\n        type: 'declaration',\n        name: target ? target.value : null,\n        variant: variant ? variant.value : null,\n        value: body\n    };\n});\n","const optional = require('../tools/optional');\nconst combine = require('../tools/combine');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst check = require('../tools/check');\nconst multiplier = require('./multiplier');\nconst combinator = require('./combinator');\n\nmodule.exports = maybe(stream => {\n\n    // It may be a group\n    if (!optional(stream, 'punc', '[')) {\n        return null;\n    }\n\n    const values = [];\n    const parsers = combine(\n        require('./type'),\n        require('./group'),\n        require('./character-range'),\n        require('./string')\n    );\n\n    let comg;\n    while (!check(stream, 'punc', ']')) {\n        const value = parsers(stream);\n        const com = combinator(stream);\n\n        if (!value) {\n            return stream.throwError('Expected a type, group or raw string.');\n        }\n\n        if (com) {\n\n            // Append to previous group\n            if (comg) {\n                if (com.value === comg.sign) {\n                    comg.value.push(value);\n                    continue;\n                } else {\n                    values.push(comg);\n                    comg = null;\n                }\n            }\n\n            // Consume next\n            comg = {\n                type: 'combinator',\n                sign: com.value,\n                value: [value]\n            };\n        } else if (comg) {\n            comg.value.push(value);\n            values.push(comg);\n            comg = null;\n        } else {\n            values.push(value);\n        }\n    }\n\n    if (comg) {\n        values.push(comg);\n    }\n\n    expect(stream, 'punc', ']');\n    return {\n        type: 'group',\n        multiplier: multiplier(stream),\n        value: values\n    };\n});\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\n\nconst types = {\n    '*': 'zero-infinity',\n    '+': 'one-infinity',\n    '?': 'optional'\n};\n\nmodule.exports = maybe(stream => {\n    const mp = optional(stream, 'punc', '*', '+', '?', '{');\n\n    if (mp && mp.value === '{') {\n        const start = expect(stream, 'num');\n        expect(stream, 'punc', ',');\n\n        const end = expect(stream, 'num');\n        if (start.value < 0 || end.value < 0) {\n            return stream.throwError('Range values cannot contain negative values.');\n        } else if (end.value - start.value < 0) {\n            return stream.throwError('The difference between start and end-value cannot be negative or zero.');\n        }\n\n        expect(stream, 'punc', '}');\n        return {\n            type: 'range',\n            value: {\n                start: start.value,\n                end: end.value\n            }\n        };\n    }\n\n    return mp ? {\n        type: types[mp.value],\n        value: mp.value\n    } : null;\n});\n","const identifier = require('./identifier');\nconst optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst multiplier = require('./multiplier');\nconst string = require('./string');\n\nmodule.exports = maybe(stream => {\n\n    // It MAY be a type, dosn't need to though.\n    if (!optional(stream, 'punc', '<')) {\n        return null;\n    }\n\n    const ident = identifier(stream);\n    if (!ident) {\n        return stream.throwError('Expected identifier.');\n    }\n\n    let tag = null;\n    if (optional(stream, 'punc', '#')) {\n        tag = string(stream) || identifier(stream);\n\n        if (!tag) {\n            return stream.throwError('Expected string or identifier as tag.');\n        }\n\n        tag = tag.value;\n    }\n\n    expect(stream, 'punc', '>');\n    return {\n        type: 'type',\n        multiplier: multiplier(stream),\n        value: ident.value,\n        tag\n    };\n});\n","const optional = require('../tools/optional');\nconst maybe = require('../tools/maybe');\n\nmodule.exports = maybe(stream => {\n    const string = optional(stream, 'str');\n\n    if (string && !string.value.length) {\n        return stream.throwError('Strings shouldn\\'t be empty.');\n    }\n\n    return string ? {\n        type: 'string',\n        value: string.value\n    } : null;\n});\n","module.exports = (stream, predicate) => {\n    let result = '';\n\n    while (stream.hasNext() && predicate(stream.peek())) {\n        result += stream.next();\n    }\n\n    return result;\n};\n","module.exports = {\n    compile: require('./compiler'),\n    version: '0.0.1'\n};\n","const resolveScope = require('./tools/resolve-scope');\nconst typeValue = require('./parser/type-value');\nconst createStream = require('../stream');\nconst ast = require('../ast');\n\nmodule.exports = definitions => {\n    const tree = ast(definitions);\n    let entry = null;\n\n    // Resolve entities in the global scope\n    const globals = resolveScope(tree, null, ({variant, name, value}) => {\n        if (variant === 'entry') {\n\n            // There can only be one entry type\n            if (entry) {\n                throw `There can only be one entry type. Got \"${name}\" as second one.`;\n            }\n\n            entry = value;\n        }\n    });\n\n    // Check if entry node is declared\n    if (!entry) {\n        throw 'Couldn\\'t resolve entry type. Use the entry keyword to declare one.';\n    }\n\n    return content => {\n        const stream = createStream(content);\n        const res = typeValue(stream, entry, globals);\n        return stream.hasNext() ? null : res;\n    };\n};\n","/**\n * Parses a character-range\n * @param stream Character-stream\n * @param value\n * @param result\n * @returns {null|*}\n */\nmodule.exports = (stream, {value: {from, to}}, result) => {\n    if (!stream.hasNext()) {\n        return false;\n    }\n\n    // Resolve next character / char-code\n    const value = stream.next();\n    const charCode = value.charCodeAt(0);\n\n    // Check if charcode matches given range\n    if (charCode >= from && charCode <= to) {\n        result.str += value;\n        return true;\n    }\n\n    return false;\n};\n","module.exports = (stream, decl, scope, result) => {\n    const delcaration = require('./declaration');\n    stream.stash();\n\n    switch (decl.sign) {\n        case '|': {\n\n            // Match one of the items\n            for (const val of decl.value) {\n                if (delcaration(stream, val, scope, result)) {\n                    stream.recycle();\n                    return true;\n                }\n            }\n\n            break;\n        }\n        case '&': {\n            const cpy = [...decl.value];\n\n            // Match items ignoring the order\n            for (let i = 0; i < cpy.length; i++) {\n                if (delcaration(stream, cpy[i], scope, result)) {\n                    stream.recycle();\n                    cpy.splice(i, 1);\n                    i = -1;\n                }\n            }\n\n            // Every item needs to be matched\n            if (!cpy.length) {\n                return true;\n            }\n\n            break;\n        }\n    }\n\n    stream.pop();\n    return null;\n};\n","/**\n * Parses a single string\n * @param stream Character-stream\n * @param value Deconstructed value of a string-type\n * @param result\n * @returns {null|*}\n */\nmodule.exports = (stream, {value}, result) => {\n    if (!stream.hasNext()) {\n        return false;\n    }\n\n    stream.stash();\n    for (let i = 0; i < value.length; i++) {\n        const next = stream.next();\n\n        // Check for type mismatch\n        if (next !== value[i]) {\n            stream.pop();\n            return false;\n        }\n    }\n\n    stream.recycle();\n    result.str += value;\n    return true;\n};\n","const multiplier = require('./multiplier');\n\nmodule.exports = (stream, decl, scope, result) => {\n    const typeValue = require('./type-value');\n    const {value} = decl;\n\n    // Lookup parser\n    if (!scope.has(value)) {\n        throw `Cannot resolve \"${value}\"`;\n    }\n\n    // Parse\n    stream.stash();\n    const body = scope.get(value);\n\n    // Type may have a multiplier attached to it\n    const matches = multiplier(\n        () => typeValue(stream, body, scope)\n    )(stream, decl, scope, result);\n\n    if (!matches) {\n\n        // Restore previous stack position\n        stream.pop();\n\n        // Declaration may be still optional through a '?'\n        return decl.multiplier && decl.multiplier.type === 'optional';\n    }\n\n    if (decl.tag) {\n        result.pure = false; // Result is not anymore \"just a string\"\n        result.obj[decl.tag] = matches; // Save tag-result TODO: Check if already declared\n    } else if (Array.isArray(matches)) {\n        result.str += matches.join(''); // Concat string sequences\n    } else if (typeof matches === 'string') {\n        result.str += matches;\n    } else {\n        throw `Type \"${decl.value}\" is missing a tag.`;\n    }\n\n    stream.recycle();\n    return true;\n};\n","const resolveScope = require('../tools/resolve-scope');\nconst group = require('./group');\n\nmodule.exports = (stream, decl, scope) => {\n\n    // Inherit current scope\n    let def = null;\n    const newScope = resolveScope(decl.value, scope, ({variant, value}) => {\n        if (variant === 'default') {\n            if (def !== null) {\n                throw 'There can only be one default export.';\n            }\n\n            def = value;\n        } else if (variant === 'entry') {\n            throw 'The entry type needs to be in the global scope.';\n        }\n    });\n\n    if (!def) {\n        throw 'Missing default export.';\n    }\n\n    return group(stream, def, newScope);\n};\n","const prettyPrintError = require('./pretty-print-error');\n\nmodule.exports = class ParsingError extends Error {\n\n    /**\n     * Sytax-error with message and position\n     * @param source\n     * @param msg\n     * @param start\n     * @param end\n     */\n    constructor(source, msg, start, end) {\n        super(`\\n${prettyPrintError(source, msg, start, end)}`);\n        this.start = start;\n        this.end = end;\n        this.name = 'Parsing Error';\n    }\n};\n","const previousIndexOf = require('previous-index-of');\nconst MAX_LOOKBACK = 10;\n\n/* eslint-disable no-console */\n/**\n * Pretty-prints an error-message\n * @param src the source-code\n * @param message error message\n * @param start error-offset\n * @param end error-end index\n */\nmodule.exports = (src, message, start, end) => {\n    const prevLineBreak = alternative(previousIndexOf(src, '\\n', start), 0);\n    const nextLineBreak = alternative(src.indexOf('\\n', end), src.length);\n    const sourceLines = resolveSourceLines(src, nextLineBreak);\n    const col = (start - prevLineBreak);\n    let msg = '';\n\n    const totalLines = countLines(src);\n    const totalLinesMaxStrLength = Math.max(String(totalLines).length, 2);\n\n    // Remove empty trailing lines\n    while (sourceLines.length && !sourceLines[0].trim()) {\n        sourceLines.splice(0, 1);\n    }\n\n    // Check if lines where omitted\n    const omittedLines = totalLines - sourceLines.length;\n    if (omittedLines >= 1) {\n        msg += `... (${omittedLines} line${omittedLines === 1 ? '' : 's'} omitted)\\n`;\n    }\n\n    // Pretty-print lines\n    for (let i = 0; i < sourceLines.length; i++) {\n        const line = sourceLines[i];\n        const lineOffset = totalLines - sourceLines.length + i + 1;\n        const lineCount = String(lineOffset).padStart(totalLinesMaxStrLength, '0');\n        msg += `${lineCount}: ${line}\\n`;\n    }\n\n    msg += `${' '.repeat(col + totalLinesMaxStrLength)}^\\n`;\n    msg += message;\n    return msg;\n};\n\nfunction trimLine(line) {\n    return line.replace(/^[\\n\\r]+|[\\n\\r ]+$/g, '');\n}\n\nfunction countLines(src) {\n    let count = 0;\n\n    for (const ch of src) {\n        count += ch === '\\n' ? 1 : 0;\n    }\n\n    return count;\n}\n\nfunction resolveSourceLines(src, end) {\n    const lines = [];\n\n    // Backtrack lines\n    let prevIndex = end;\n    while (lines.length < MAX_LOOKBACK) {\n        const nextIndex = previousIndexOf(src, '\\n', prevIndex - 1);\n\n        if (~nextIndex) {\n            const line = src.substring(nextIndex, prevIndex);\n            lines.splice(0, 0, trimLine(line));\n            prevIndex = nextIndex;\n        } else {\n            break;\n        }\n    }\n\n    if (!lines.length && src.length) {\n        lines.push(trimLine(src));\n    } else if (lines.length < MAX_LOOKBACK) {\n        const trailingLine = trimLine(src.slice(0, prevIndex));\n\n        // The first line won't be matched by the previous loop.\n        if (trailingLine) {\n            lines.splice(0, 0, trailingLine);\n        }\n    }\n\n    return lines;\n}\n\nfunction alternative(val, fallback, pred = -1) {\n    return val === pred ? fallback : val;\n}\n","/**\n * Returns the previous index of a string at a given offset.\n * If the target is not a string or the offset is below the length of the target\n * it returns -1.\n *\n * If offset isn't a string it will be set to the length of the source string.\n *\n * @param str Source string\n * @param target Target string\n * @param offset Offset (inclusive)\n * @returns {number|*} The offset of the target string or -1 if the offset wasn't found.\n */\nmodule.exports = (str, target, offset) => {\n\n    // Immediatly return -1 if offset is below target length or non-strings where used as target or source\n    if (typeof target !== 'string' || typeof str !== 'string' || offset < target.length - 1) {\n        return -1;\n    }\n\n    // Set offset to the length of the source string if it isn't a number\n    if (typeof offset !== 'number') {\n        offset = str.length - 1;\n    }\n\n    // Reverse-search for target-string offset\n    const targetLength = target.length - 1;\n    for (let i = offset, toff = targetLength; i >= 0; i--) {\n\n        if (str[i] === target[toff]) {\n            toff--;\n\n            // Check if target string got fully matched\n            if (!~toff) {\n                return i;\n            }\n        } else if (toff !== targetLength) {\n            toff = targetLength;\n            i++;\n        }\n    }\n\n    return -1;\n};\n","const declaration = require('./nodes/declaration');\nconst tokenize = require('../tokenizer');\nconst createStream = require('../stream');\n\n/**\n * Converts a array of tokens into a ast-tree\n * @param defs\n */\nmodule.exports = defs => {\n    const stream = createStream(tokenize(defs), defs);\n    const declarations = [];\n\n    while (stream.hasNext()) {\n        const dec = declaration(stream);\n\n        if (dec) {\n            declarations.push(dec);\n        } else {\n            return stream.throwError('Expected type-declaration.');\n        }\n    }\n\n    return declarations;\n};\n","/**\n * Accepts a list of parser and returns the first who matches the input\n * @param parsers\n * @returns {Function}\n */\nmodule.exports = (...parsers) => stream => {\n    for (const parser of parsers) {\n        const result = parser(stream);\n\n        if (result) {\n            return result;\n        }\n    }\n\n    return null;\n};\n","const optional = require('../tools/optional');\nconst maybe = require('../tools/maybe');\n\nmodule.exports = maybe(stream => {\n    const combinator = optional(stream, 'punc', '|', '&');\n\n    return combinator ? {\n        type: 'combinator',\n        value: combinator.value\n    } : null;\n});\n","const maybe = require('../tools/maybe');\n\n/**\n * Parses an identifier made out of keywords, numbers or hyphens\n * @type {Function}\n */\nmodule.exports = maybe(stream => {\n    let name = '';\n\n    while (stream.hasNext(true)) {\n        const {type, value} = stream.peek(true);\n\n        if (type === 'kw' || type === 'num' || (type === 'punc' && (value === '-' || value === ':'))) {\n            name += value;\n            stream.next(true);\n        } else {\n            break;\n        }\n    }\n\n    if (!name.length) {\n        return stream.throwError('An identifier cannot be empty.');\n    }\n\n    return {\n        type: 'identifier',\n        value: name || null\n    };\n});\n","const unicodeEscape = require('../tools/unicode-escape');\r\nconst optional = require('../tools/optional');\r\nconst maybe = require('../tools/maybe');\r\n\r\nconst parsePoint = stream => {\r\n    const str = optional(stream, 'str');\r\n\r\n    if (str) {\r\n        const {value} = str;\r\n        return value.length === 1 ? value.charCodeAt(0) : null;\r\n    }\r\n\r\n    return unicodeEscape(stream);\r\n};\r\n\r\nmodule.exports = maybe(stream => {\r\n    let from = parsePoint(stream);\r\n\r\n    // The keyword 'to' indicates a character range\r\n    if (from === null || !optional(stream, 'kw', 'to')) {\r\n        return null;\r\n    }\r\n\r\n    let to = parsePoint(stream);\r\n    if (to === null) {\r\n        return stream.throwError('Expected range-end');\r\n    }\r\n\r\n    if (to < from) {\r\n        [to, from] = [from, to];\r\n    }\r\n\r\n    return {\r\n        type: 'character-range',\r\n        value: {\r\n            from,\r\n            to\r\n        }\r\n    };\r\n});\r\n","const optional = require('./optional');\nconst maybe = require('./maybe');\n\nmodule.exports = maybe(stream => {\n\n    if (!optional(stream, 'punc', '\\\\') || !stream.hasNext()) {\n        return null;\n    }\n\n    const sequence = String(stream.next().value);\n    if (!sequence.startsWith('u')) {\n        return null;\n    }\n\n    // Validate length of sequence\n    if (sequence.length !== 5) {\n        return stream.throwError('An unicode-escape sequence consists out of an \"u\" followed by a code-point.');\n    }\n\n    // Validate char-codes\n    const hex = sequence.slice(1);\n    for (const char of hex) {\n        const code = char.charCodeAt(0);\n\n        if (code < 48 || (code > 57 && code < 97) || code > 102) {\n            return stream.throwError('Invalid unicode-range.');\n        }\n    }\n\n    return parseInt(hex, 16);\n});\n","const optional = require('../tools/optional');\nconst expect = require('../tools/expect');\nconst maybe = require('../tools/maybe');\nconst check = require('../tools/check');\nconst declaration = require('./declaration');\n\nmodule.exports = maybe(stream => {\n\n    // It may be a block\n    if (!optional(stream, 'punc', '{')) {\n        return null;\n    }\n\n    // Parse declarations\n    const declarations = [];\n\n    while (!check(stream, 'punc', '}')) {\n        declarations.push(declaration(stream));\n    }\n\n    expect(stream, 'punc', '}');\n    return {\n        type: 'block',\n        value: declarations\n    };\n});\n","const createStream = require('../stream');\nconst consume = require('./tools/consume');\nconst {isWhiteSpace} = require('./tools/is');\n\nconst parser = [\n    require('./types/str'),\n    require('./types/kw'),\n    require('./types/num'),\n    require('./types/punc')\n];\n\n/**\n * Parses a sequence of characters into a list of processable tokens\n * @param str\n * @returns {[]}\n */\nmodule.exports = str => {\n    const stream = createStream(str);\n    const tokens = [];\n\n    /* eslint-disable no-labels */\n    outer: while (stream.hasNext()) {\n\n        // Ignore whitespace\n        consume(stream, isWhiteSpace);\n\n        if (!stream.hasNext()) {\n            break;\n        }\n\n        // Find matching parser\n        for (const parse of parser) {\n            const start = stream.index;\n            const parsed = parse(stream);\n\n            if (!parsed) {\n                continue;\n            }\n\n            // Check if token could be the beginning of a comment\n            if (parsed.value === '/' && stream.hasNext() && stream.peek() === '/') {\n                while (stream.hasNext()) {\n                    if (stream.peek() === '\\n') {\n                        break;\n                    }\n\n                    stream.next();\n                }\n\n                continue outer;\n            }\n\n            tokens.push({\n                ...parsed, start,\n                end: stream.index\n            });\n\n            continue outer;\n        }\n\n        throw 'Failed to parse input sequence.';\n    }\n\n    return tokens;\n};\n","const escaped = require('../tools/escaped');\n\nmodule.exports = stream => {\n    for (const char of ['\\'', '\"', '`']) {\n        stream.stash();\n\n        if (stream.peek() === char) {\n            stream.next();\n\n            const value = escaped(stream, char);\n            if (value !== null) {\n                return {\n                    type: 'str',\n                    value\n                };\n            }\n        }\n\n        stream.pop();\n    }\n\n    return null;\n};\n","module.exports = (stream, end) => {\n    let escaped = false;\n    let str = '';\n\n    for (let ch = stream.next(); ; ch = stream.next()) {\n        if (escaped) {\n            str += ch;\n            escaped = false;\n        } else if (ch === '\\\\') {\n            escaped = true;\n        } else if (ch === end) {\n            return str;\n        } else if (!stream.hasNext()) {\n            break;\n        } else {\n            str += ch;\n        }\n    }\n\n    return null;\n};\n","const {isNonWhitespace, isNumeric} = require('../tools/is');\nconst consume = require('../tools/consume');\n\nmodule.exports = stream => {\n\n    if (isNonWhitespace(stream.peek())) {\n        const str = consume(stream, v => isNonWhitespace(v) || isNumeric(v));\n\n        return str ? {\n            type: 'kw',\n            value: str.toLowerCase()\n        } : null;\n    }\n\n    return null;\n\n};\n","const {isNumeric} = require('../tools/is');\n\nmodule.exports = stream => {\n\n    let number = '';\n    while (stream.hasNext()) {\n        const ch = stream.peek();\n\n        if (isNumeric(ch)) {\n            number += ch;\n        } else {\n            break;\n        }\n\n        stream.next();\n    }\n\n    return number.length ? {\n        type: 'num',\n        value: Number(number)\n    } : null;\n};\n","const {isPunctuation} = require('../tools/is');\r\n\r\nmodule.exports = stream => {\r\n\r\n    if (isPunctuation(stream.peek())) {\r\n        return {\r\n            type: 'punc',\r\n            value: stream.next()\r\n        };\r\n    }\r\n\r\n    return null;\r\n};\r\n"],"sourceRoot":""}